= Getting Started with Project Syn

This guide helps to get started with the various Project Syn tools.

TIP: Have a look at xref:features.adoc[features] and xref:architecture.adoc[architecture] first to get an idea about Project Syn, this helps to understand what we're doing here.

== Requirements

Before you start, please make sure to have these requirements available:

* A local Kubernetes cluster (k3s), managed with https://k3d.io/[k3d]
* A https://gitlab.com[GitLab.com] account with an https://gitlab.com/profile/keys[SSH key configured]
** You can use `ssh-keygen` to generate an SSH key if you don't yet have one
** Alternatively you could use your own GitLab instance (some adjustments need to be made in the guide)
* `curl` and `jq`

[TIP]
.Getting started with k3d
--
. Download k3d from https://github.com/rancher/k3d/releases[GitHub]. We're using version 1.x in this guide.
. Create a new cluster: `k3d create -n projectsyn`
. Prepare Kubectl to access this cluster: `export KUBECONFIG="$(k3d get-kubeconfig --name='projectsyn')"`
. Check that you're connected to this cluster: `kubectl cluster-info`
--

== Kickstart Lieutenant

Lieutenant is the central inventory service all Project Syn managed clusters report to, it consists of the Lieutenant _Operator_ and the Lieutenant _API_.

As you can see on the xref:architecture.adoc[architecture] diagram, Lieutenant is the central API which is being used by all other Project Syn tools. Therefore it needs to be installed first so that all other components are actually able to do their job.

Create a namespace to host the Operator and the API
[source,shell]
----
kubectl create namespace lieutenant
----

=== Install Lieutenant Operator

Install *Lieutenant Operator* with the following commands:

[source,shell]
----
# CRDs (global scope)
kubectl apply -k github.com/projectsyn/lieutenant-operator/deploy/crds

# Operator deployment
kubectl -n lieutenant apply -k github.com/projectsyn/lieutenant-operator/deploy

# Configure Lieutenant Operator to not rely on Hashicorp Vault (for now)
kubectl -n lieutenant set env deployment/lieutenant-operator -c lieutenant-operator SKIP_VAULT_SETUP=true
----

=== Install Lieutenant API

Install *Lieutenant API* with the following commands:

[source,shell]
----
# API deployment
kubectl -n lieutenant apply -k github.com/projectsyn/lieutenant-api/deploy

# Ingress
export K3S_INGRESS_IP=$(kubectl -n kube-system get svc traefik -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
kubectl -n lieutenant apply -f -<<EOF
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: lieutenant-api
spec:
  rules:
  - host: lieutenant.${K3S_INGRESS_IP}.nip.io
    http:
      paths:
      - path: /
        backend:
          serviceName: lieutenant-api
          servicePort: 80
EOF
----

Check that the API is accessible:

[source,shell]
----
echo http://lieutenant.${K3S_INGRESS_IP}.nip.io/healthz
curl http://lieutenant.${K3S_INGRESS_IP}.nip.io/healthz
----
This should return `ok` as the answer to the `curl` command. You can see this is the same API Commodore and Steward will use (in this getting started guide without https and using the nip.io dynamic URL).

TIP: The API documentation can be accessed in your browser under http://lieutenant.${K3S_INGRESS_IP}.nip.io/docs.

=== Prepare Lieutenant Operator access to GitLab

Lieutenant needs API access to a GitLab server. This is required to create and manage Git repositories for clusters and tenants.

[NOTE]
.What are tenants?
====
A "tenant" is an entity to assign clusters to. This entity could be a customer, a department, a team, or anything you want to group clusters with. This concept is also used by Commodore, as every tenant gets his own configuration Git repository to (for example) apply common settings to all clusters belonging to a particular tenant. Any cluster specific configuration values are stored in that tenant's own configuration Git repository.
====

Create a Kubernetes secret which contains the access token for the GitLab API, which can be generated here: https://gitlab.com/profile/personal_access_tokens (needs `api` scope, amend gitlab.com with your own GitLab instance URL if needed).

Replace `MYTOKEN` with the generated GitLab API token. If you're using your own GitLab instance, amend `GITLAB_ENDPOINT` and `GITLAB_SSH_HOST_KEY` (You can use the `ssh-keyscan` tool to get the SSH host key of your own GitLab instance).

[source,shell]
----
export GITLAB_TOKEN=MYTOKEN
export GITLAB_ENDPOINT=gitlab.com
export GITLAB_SSH_HOST_KEY="gitlab.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf"
kubectl -n lieutenant create secret generic vshn-gitlab \
  --from-literal=endpoint="https://${GITLAB_ENDPOINT}" \
  --from-literal=hostKeys="${GITLAB_SSH_HOST_KEY}" \
  --from-literal=token=${GITLAB_TOKEN}
----

NOTE: This secret currently needs to be named exactly like that. See https://syn.tools/lieutenant-api/deployment.html#_gitlab[syn.tools] and https://github.com/projectsyn/lieutenant-operator/issues/48[GitHub issue] for more information.

=== Prepare Lieutenant API Authentication and Authorization

As the Lieutenant API uses the underlying Kubernetes cluster for authentication and authorization, the following objects need to be created:

* `Role`
* `RoleBinding`
* `ServiceAccount`

[source,shell]
----
kubectl -n lieutenant apply -f -<<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: lieutenant-api-user
rules:
- apiGroups:
  - syn.tools
  resources:
  - clusters
  - tenants
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: lieutenant-api-user
roleRef:
  kind: Role
  name: lieutenant-api-user
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: api-access-synkickstart
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: api-access-synkickstart
EOF
----

=== Create Lieutenant Objects: Tenant and Cluster

In this section you will create your first Lieutenant configuration objects using the API to test the deployment and configuration.

. Prepare access to API, replace `MYUSER` with your GitLab user id
+
[source,shell]
----
export LIEUTENANT_TOKEN=$(kubectl -n lieutenant get secret $(kubectl -n lieutenant get sa api-access-synkickstart -o go-template='{{(index .secrets 0).name}}') -o go-template='{{.data.token | base64decode}}')
export LIEUTENANT_AUTH="Authorization: Bearer ${LIEUTENANT_TOKEN}"
export LIEUTENANT_URL="lieutenant.${K3S_INGRESS_IP}.nip.io"
export GITLAB_USERNAME="MYUSER"
----

. Create a *Lieutenant Tenant* via the API
+
[source,shell]
----
TENANT_ID=$(curl -s -H "$LIEUTENANT_AUTH" -H "Content-Type: application/json" -X POST --data "{\"displayName\":\"My first Tenant\",\"gitRepo\":{\"url\":\"ssh://git@${GITLAB_ENDPOINT}/${GITLAB_USERNAME}/mytenant.git\"}}" "http://${LIEUTENANT_URL}/tenants" | jq -r ".id")
echo $TENANT_ID
echo https://${GITLAB_ENDPOINT}/${GITLAB_USERNAME}/mytenant
----
+
TIP: If everything went well, the Lieutenant Operator created a new git repository under https://${GITLAB_ENDPOINT}/${GITLAB_USERNAME}/mytenant, which will be used to store the configuration used by Commodore to create a catalog for a cluster.

. Retrieve the registered Tenants via API and directly on the cluster
+
[source,shell]
----
curl -H "$LIEUTENANT_AUTH" "http://${LIEUTENANT_URL}/tenants"
kubectl -n lieutenant get tenant
kubectl -n lieutenant get gitrepo
----

. Register a *Lieutenant Cluster* via the API
+
[source,shell]
----
CLUSTER_ID=$(curl -s -H "$LIEUTENANT_AUTH" -H "Content-Type: application/json" -X POST --data "{ \"tenant\": \"${TENANT_ID}\", \"displayName\": \"My first Project Syn cluster\", \"facts\": { \"cloud\": \"local\", \"distribution\": \"k3s\", \"region\": \"local\" }, \"gitRepo\": { \"url\": \"ssh://git@${GITLAB_ENDPOINT}/${GITLAB_USERNAME}/cluster-gitops1.git\" } }" "http://${LIEUTENANT_URL}/clusters" | jq -r ".id")
echo $CLUSTER_ID
echo https://${GITLAB_ENDPOINT}/${GITLAB_USERNAME}/cluster-gitops1
----
+
TIP: If everything went well, the Lieutenant Operator created a new git repository under https://${GITLAB_ENDPOINT}/${GITLAB_USERNAME}/cluster-gitops1 which will be used to store the generated catalog of deployment files.

. Retrieve the registered Clusters via API and directly on the cluster
+
[source,shell]
----
curl -H "$LIEUTENANT_AUTH" "http://${LIEUTENANT_URL}/clusters"
kubectl -n lieutenant get cluster
kubectl -n lieutenant get gitrepo
----

== Kickstart Commodore

Commodore is the configuration generation tool. It will be configured to generate configuration for your Lieutenant cluster `$CLUSTER_ID` generated above. With all the information available in Lieutenant, Commodore is able to figure out what to actually compile for the cluster in question and where to Git push the compiled catalog to.

Before continuing with this section, make sure that everything went well with the installation and configuration of Lieutenant as Commodore relies on having a working instance of it.

=== Run Commodore

The easiest way of executing Commodore is by using the container image provided by Project Syn: https://hub.docker.com/r/projectsyn/commodore[docker.io/projectsyn/commodore]. We run the image directly in the local `k3s` instance so that there is no need for having another container runtime installed.

Execute the following command which will start the properly configured Commodore container inside your local `k3s` instance.

Replace `MYSSHKEYPATH` with the path to your SSH key file, for example `~/.ssh/id_rsa`. This SSH key will be used to push the generated configuration catalog to the Git repository managed by Lieutenant.

[source,shell]
----
export COMMODORE_SSH_PRIVATE_KEY=MYSSHKEYPATH
kubectl -n lieutenant run commodore-shell \
  --image=docker.io/projectsyn/commodore:latest \
  --env=COMMODORE_API_URL="http://${LIEUTENANT_URL}/" \
  --env=COMMODORE_API_TOKEN=${LIEUTENANT_TOKEN} \
  --env=COMMODORE_GLOBAL_GIT_BASE=https://github.com/projectsyn \
  --env=SSH_PRIVATE_KEY="$(cat ${COMMODORE_SSH_PRIVATE_KEY})" \
  --env=CLUSTER_ID=${CLUSTER_ID} \
  --env=GITLAB_ENDPOINT=${GITLAB_ENDPOINT} \
  --tty --stdin --restart=Never --rm --wait \
  --image-pull-policy=Always \
  --command \
  -- /usr/local/bin/entrypoint.sh bash
----

If your SSH key is protected by a passphrase (hopefully so!) no command prompt will be displayed and it will look like it halted at `If you don't see a command prompt, try pressing enter`. Don't just press "enter" but type your SSH key passphrase (an `ssh-agent` is started in the container's entrypoint) and press "enter" after that.

When there is no passphrase on your SSH key, the command prompt should directly show up.

Now run (inside the container):

[source,shell]
----
ssh-keyscan ${GITLAB_ENDPOINT} >> /app/.ssh/known_hosts
commodore compile $CLUSTER_ID --push
----

The output will look like this:

[source]
----
Cleaning working tree
Updating global config...
Updating customer config...
Discovering components...
Fetching components...
Updating Kapitan target...
Updating cluster catalog...
 > Reference at 'refs/heads/master' does not exist, creating initial commit for catalog
Updating Jsonnet libraries...
Cleaning catalog repository...
 > Converting old-style catalog
Updating Kapitan secret references...
Compiling catalog...
...
 > Commiting changes...
 > Pushing catalog to remote...
Catalog compiled! ðŸŽ‰
----

You now have your first Commodore compiled catalog available under `catalog/` and pushed to GitLab to the cluster catalog repository.

To see what was just generated, browse to https://${GITLAB_ENDPOINT}/${GITLAB_USERNAME}/cluster-gitops1 (or do a `find catalog/`) to see the Git commit (and Git push) Commodore created and all the generated Kubernetes objects. These objects will then actually be applied to the cluster by Argo CD (we've not installed Argo CD in this guide).

TIP: This guide uses https://github.com/projectsyn/commodore-defaults/ as the global common configuration repository. If you want to use your own, adapt the `COMMODORE_GLOBAL_GIT_BASE` environment variable. Currently the Git repo needs to be named `commodore-defaults`.

== Cleaning Up

Once you've gone through all these steps, you can cleanup all generated stuff using the following steps:

. Delete the k3d cluster: `k3d delete -n projectsyn`
. Delete the two Git repositories on GitLab

== Getting Started Guide Roadmap

This guide will evolve over time. You're currently looking at the initial release where the focus lies on Lieutenant and Commodore. Planned:

* Add guidelines for Hashicorp Vault
* Guide how to use Steward
